# Generated by Django 5.1.9 on 2025-09-24 14:22

import wagtail.fields
from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('adl_collector_app_plugin', '0004_manualobservationstationlink_schedule_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='manualobservationstationlinkvariablemapping',
            name='qc_checks',
            field=wagtail.fields.StreamField([('range_check', 3), ('step_check', 7), ('persistence_check', 11), ('spike_check', 15)], blank=True, block_lookup={0: ('wagtail.blocks.FloatBlock', (), {'help_text': "The smallest acceptable value for this parameter. Leave blank if there's no minimum limit.", 'required': False}), 1: ('wagtail.blocks.FloatBlock', (), {'help_text': "The largest acceptable value for this parameter. Leave blank if there's no maximum limit.", 'required': False}), 2: ('wagtail.blocks.BooleanBlock', (), {'default': True, 'help_text': 'Check this box if the min/max values themselves are acceptable. Uncheck if they should be excluded.', 'required': False}), 3: ('wagtail.blocks.StructBlock', [[('min_value', 0), ('max_value', 1), ('inclusive_bounds', 2)]], {'label': 'Range Check'}), 4: ('wagtail.blocks.FloatBlock', (), {'help_text': 'Maximum allowed jump between consecutive readings. Larger jumps usually indicate sensor problems.', 'min_value': 0, 'required': True}), 5: ('wagtail.blocks.FloatBlock', (), {'help_text': 'Maximum rate of change per minute. Leave blank to only check absolute jumps.', 'min_value': 0, 'required': False}), 6: ('wagtail.blocks.IntegerBlock', (), {'default': 30, 'help_text': "Skip this check if there's been a data gap longer than this many minutes. This prevents false alarms after maintenance or outages.", 'min_value': 1, 'required': True}), 7: ('wagtail.blocks.StructBlock', [[('max_step_change', 4), ('max_step_change_per_minute', 5), ('ignore_after_gap_minutes', 6)]], {'label': 'Step Check'}), 8: ('wagtail.blocks.IntegerBlock', (), {'default': 10, 'help_text': 'Flag the data if this many consecutive readings are identical. For example, 10 identical readings might indicate a stuck sensor.', 'min_value': 2, 'required': True}), 9: ('wagtail.blocks.FloatBlock', (), {'default': 0.001, 'help_text': "How close values need to be to count as 'identical'. Use 0.1 for whole numbers, 0.01 for one decimal place, etc.", 'min_value': 0, 'required': True}), 10: ('wagtail.blocks.BooleanBlock', (), {'default': True, 'help_text': 'Allow zero values to repeat without triggering alerts. Useful for parameters like precipitation that naturally stay at zero.', 'required': True}), 11: ('wagtail.blocks.StructBlock', [[('max_identical_readings', 8), ('tolerance', 9), ('allow_zero_persistence', 10)]], {'label': 'Persistence Check'}), 12: ('wagtail.blocks.FloatBlock', (), {'default': 3.0, 'help_text': "How many 'standard deviations' away from normal before flagging as a spike. 3.0 catches extreme outliers, 2.0 is more strict.", 'min_value': 0.1, 'required': True}), 13: ('wagtail.blocks.IntegerBlock', (), {'default': 20, 'help_text': "Number of previous readings to analyze for 'normal' behavior. More samples give better statistics but use older data.", 'min_value': 5, 'required': True}), 14: ('wagtail.blocks.IntegerBlock', (), {'default': 5, 'help_text': "Minimum previous readings needed before spike detection starts working. Prevents errors when there's insufficient data.", 'min_value': 3, 'required': True}), 15: ('wagtail.blocks.StructBlock', [[('threshold_multiplier', 12), ('lookback_samples', 13), ('min_samples', 14)]], {'label': 'Spike Check'})}, help_text='Configure automatic data quality validation rules for this parameter.', null=True, verbose_name='Quality Control Checks'),
        ),
    ]
